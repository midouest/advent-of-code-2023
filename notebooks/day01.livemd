# Day 1

```elixir
Mix.install([
  {:kino, "~> 0.11.3"}
])
```

## Puzzle

```elixir
textarea = Kino.Input.textarea("Input")
```

```elixir
input = Kino.Input.read(textarea)
```

<!-- livebook:{"branch_parent_index":0} -->

## Part 1

```elixir
calibration_value = fn line ->
  chars =
    line
    |> String.graphemes()

  {first, _} =
    chars
    |> Enum.find(&String.match?(&1, ~r/\d/))
    |> Integer.parse()

  {last, _} =
    chars
    |> Enum.reverse()
    |> Enum.find(&String.match?(&1, ~r/\d/))
    |> Integer.parse()

  Integer.undigits([first, last])
end
```

```elixir
answer =
  input
  |> String.trim_trailing()
  |> String.splitter("\n")
  |> Enum.map(calibration_value)
  |> Enum.sum()
```

<!-- livebook:{"branch_parent_index":0} -->

## Part 2

```elixir
to_digit = fn
  "zero" -> 0
  "one" -> 1
  "two" -> 2
  "three" -> 3
  "four" -> 4
  "five" -> 5
  "six" -> 6
  "seven" -> 7
  "eight" -> 8
  "nine" -> 9
  d -> Integer.parse(d) |> elem(0)
end

calibration_value = fn line ->
  matches =
    0..(String.length(line) - 1)
    |> Enum.map(
      &Regex.run(~r/\d|zero|one|two|three|four|five|six|seven|eight|nine/, line, offset: &1)
    )
    |> Enum.filter(&(!is_nil(&1)))
    |> Enum.flat_map(&Function.identity/1)

  first =
    List.first(matches)
    |> to_digit.()

  last =
    List.last(matches)
    |> to_digit.()

  Integer.undigits([first, last])
end
```

```elixir
answer =
  input
  |> String.trim_trailing()
  |> String.splitter("\n")
  |> Enum.map(calibration_value)
  |> Enum.sum()
```

<!-- livebook:{"offset":1525,"stamp":{"token":"XCP.pJrNGxs02ujI6WvOuLPvVvJ9RpHcQgOd1r8FxE6buCVGHFkEhUt0aJwJpcD1nyVf6wzwtrGjJD2ay7d1KehiDsCZPuVHqxL0pbPZPyeiQQVyQEe_G0M","version":2}} -->
